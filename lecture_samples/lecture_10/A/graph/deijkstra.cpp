// deijkstra
// 1.находим мин из неиспользованных вершин
// 2.обновляем если новый путь меньше чем до этого было
#include <iostream>
#include <vector>
#define MAX_INT 1e7
using namespace std;
int n,m,x,y,l;
int g[100][100];
int u[100];
int c[100]; // будем хранить минимальный путь до любой вершины
vector<int> d(100,MAX_INT);

int main(){
    cin >> n >> m;
    for(int i=0;i<m;i++){
        cin >> x >> y >> l;
        x--; y--;
        g[y][x]=l;
        g[x][y]=l;
    }
    d[0]=0;
    for(int i=0;i<n;i++){
        int v=-1;
        for(int j=0;j<n;j++){
            if(!u[j] && (v==-1 || d[v]>d[j])){ //находим мин вершину,до которой расстояние мин и который   нот юзед
                v=j;
            }
        }
        // cout << v+1 << endl;
        u[v]=true; // теперь эта вершина юзед

        for(int j=0;j<n;j++){ // обходим фориком все вершины которые с ней связаны
            if(!u[j] && g[v][j]>0){ //заходим если нот юзед и связаны
                if(d[j] > d[v]+g[v][j]){ // если путь до вершины j больше чем путь с вершины v (d[v]+g[v][j])
                    d[j] = d[v]+g[v][j]; // обновляем
                    c[j]=v; //храним что в вершину j пришли c вершины v,тем самым храним мин путь до этой вершины 
                }
            }
        }
        
    }
    for(int i=0;i<n;i++){
        cout << d[i] << " "; 
    }
    cout << endl;
    for(int i=0;i<n;i++){
        cout << c[i] << " ";
    }

    return 0;

}